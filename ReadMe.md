If you've ever used apps like YTmusic or Spotify you would notice that they have this very mesmerising and satisfying animation that is triggered when you rearrange the songs that are to play next in your playlist amd so naturally I thought...Is it possible to do something similar using just Vanilla JS? And that's precisely how this project was born. It took me about two weeks to complete, most of that time was me brainstorming the logic behind it than actually doing the coding. Anyways now I'll try to walk you through my process in achieving this final result so let's get into it.

Before I start I'll like to give a big shoutout to the WebDevSimplified Youtube channel. Thier video on using draggables in Javascript was of massive help in this project. I'll have a link to that video at the end of this ReadMe.

Okay so at its core, all I'm doing here is that when an item is dragged in the list, a clone of that item is created using the 'cloneNode' javascript method. This clone is given a class of 'dragging-clone' which is a class with properties such as hidden visibility and an animation to scale the height of the clone from zero(0px) to its actual height(of 50px). This gives that effect of seperation between the items in the DOM as we dragover them, when in actuality it's just an invisible clone of our dragged item with a nice animation on its height.

So yeah that explains how we are giving the illusion that the list items move apart for our dragged item, however how do we know where to insert this clone? Well that is where two of the most important functions of this our program come into play. The first one is the getAfterElement() function. The logic behind this function is perfectly explained in the draggable video by WebDevSimplified and as I mentioned earlier I'll leave a link to that video at the bottom of this Readme document. However a surface rundown on how it works is that it is fired for every dragover event that is triggered on our container element. It takes in two parameters, the first one is our container node that contains all our list itmes, the second is the vertical position of the mouse in the viewport when the event was fired (we can easily access it using the clientY property of the event object). We loop through all the items in the list by using the reducer javascript method on the container parameter we passed in earlier, and then for each item we calculate the offset between our mouse and the center of that item with the aid of the vertical position of our mouse we passed in earlier. The item whose offset is the least of all the items we looped through is the item we are closest to. However an important thing to note is that this offset is calculated based on how far above the center of the item the mouse is, so we are not really concerened with when we are below the item's center only above it. What this means is that if we dragged our mouse below the center of an item, even though technically that is the closest item to our mouse in the DOM(since we are literally dragging over it) the afterElement function would return the sibling item below as the closest item to our mouse.This is going to play an important role in our code later.


The element returned by our afterElement function is stored in a variable called 'afterElement' which is in turn passed into our DraggingClone class as we instantiate it. This class has four methods:

cloneMainFunc(): This method has three conditional clauses. The first condition is satisfied when there is no clone in the DOM yet(so basically when this is the first time we drag an item or we had previously completed a drag and drop operation and just began another one) so it runs the cloneCreateHandler method. The second condition is satisfied when there's already a clone in the DOM but the previous afterElement passed into the DraggingClone class is the same as the current afterElement that was just passed into it. When this clause executes, a return statement is simply thrown and nothing else. What this does is that if the user were to hold the dragged item above an item in the list, despite the fact that the dragover event keeps firing no new clones are created in the DOM since the afterElemnt remains the same. The third condition is satisfied when there is already a clone in the DOM but the afterElement has changed so we need to remove the previous clone whilst creating a new one to place appropriately in the DOM. Now this is fine and all but there is a bit of a catch here and that is the fact that if we were to just remove the previous clone while creating a new one, the result is what we want but in a really janky fashion since the previous clone is effectly just popped out of the UI. To achieve a much smoother result, we do not initially remove the previous clone from the UI when we create a new one, but rather we simply add a 'shrink' class to it. What this class does is simply append an animation to the clone which would animate its height to zero(0px). Then this previous clone is added to a global array called 'draggingCloneArr' and given a 'prev' class to identify it as a previous clone against next time this condition runs. The next time the condition runs we search the DOM for the clone with the 'prev' class, remove it from the DOM. Afterwards we search  the DOM for a clone withouth the 'prev' class and effectively add a 'shrink' and 'prev' class to it while replacing the previous clone(which we have now removed from the DOM) in the 'draggingCloneArr' with it. What this all does is that we sort of delay when we remove the clone, hence giving it enough time to animate its height to zero(0px) before being removed. The result is a much smoother and appealing exit of the previous clones as we create new ones. I plan on perhaps later optimizing the code by using the setTimeOut() function to cause the delay rather than doing all this, however this is the approach I took for now.

cloneCreateHandler(): The name is quite explanatory of what this does. It creates the clone of the dragged item, however this isn't all it does. It also assigns the current afterElement that was passed into the the DraggingClone class to a global variable called 'prevAfterElement'. It is via this 'prevAfterElement' variable we are able to check for if the afterElement has changed over time as the dragover event keeps firing. It is in this method that we also execute the second most important function in this program, the clonePositionHandler() method.

clonePositionHandler(): As the name implies, this is responsible for determining what position we place the clone, but in what sense?!...Well when we dragover an item in the list, we could either insert the clone above the item or below the item, now of course this can't be done randomly and so we need some way of determining when we are above the center of the item so we know to insert above whilst when we are below the center we insert the clone below the item. This method does this by taking advantage of something I mentioned earlier with the getAfterElement() function. That is the fact that when we are above an item's center, the getAterElement() function returns that item as the 'afterElement' while when we are below the center it returns its sibling item below it and if there is no sibling item below(when we reach the end of the list) it returns 'undefined'. So whenever the dragover event is fired we are passing in the event object into the DraggingClone class and storing it in a property called 'ev'. We then use the 'ev.target' to get the item we are curently dragging over in the DOM and compare it to the afterElement passed into the DraggingClone class as well. If the two are a match then we must be above the item and we therefore insert the clone above it. On the orther hand if the two are a mismatch, we know that we are below the item and insert the clone as follows. Remember that when we are below the center of an item we are still dragging over it so the ev.target still returns the item itself meanwhile the getAfterElement() returns its suceeding sibling item as I said earlier. However before even doing any of this we have a try and catch block for the case in which we dragged over all the way to the end of the list and our afterElement is undefined. In the try block we perform an action that would only run if the afterEleement where an actual element and throw an error if ortherwise like 'undefined' for instance.In the catch block we simply append the clone to the end of the container since this block only executes when we are at the list end anyways.

cloneRemoveHandler(): The purpose of this method is to remove clones from the DOM. A clone can be passed in as a parameter and it would remove just that specific clone. Ortherwise it would simply remove all clones present in the DOM. The first option is important as we drag an item across the list so we can remove previous clones as we create new ones, while the second options comes into play when you drop a dragged item or when you attempt to drop in a zone that doesn't allow dopping operations(Like outside the container). As a side note this method is a static method so it could be accessed withouth needing to create a new instance of the DraggingClone class, so it just makes it easier to remove clones wherever in the code.

Okay so that is it for all the methods. Some other functionality I added where that when you initially drag an item, a 'dragging' class is added to it which appends an animation to the element that scales its height to zero. This class is also important in making sure our clone is created from the item we are dragging and also in keeping track of the dragged itme in general. Another thing I do is to add a temporary class called 'temp'. This class is eventually removed and its only purpose is to mark when we just started dragging an item because we wouldn't want to a clone to be created when we just started dragging an item. So we have a condition to check for if this class is present(therefore indicating we just started dragging it) and if so we run a while loop which checks for if our afterElement is the same as the next sibling item of our dragged item, if so it means we haven't dragged the item to any new position and so we simply throw a return statement to ignore the rest of the code and not create a clone, ortherwise the class is removed and the code flows normally.

Congrats on making it to the end of this very, very, very long document. I'm glad you took your time to go through it. I know 
this code is not the best there is out there and I do admit that it has some bugs that need fixing but there is always room for improvement.Feel free to fork this code and play around with it. Thanks for reading 😁.


Web Dev Simplified Video: https://www.youtube.com/watch?v=jfYWwQrtzzY&list=PLh4keYqU4wA8-HJuFjguQHH_TqEbMq6yw&index=49